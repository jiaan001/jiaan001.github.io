{"meta":{"title":"An的博客","subtitle":"山中何事","description":"个人技术博客","author":"An","url":"https://jiaan001.github.io","root":"/"},"pages":[{"title":"关于An","date":"2021-03-13T10:51:02.000Z","updated":"2021-03-13T11:33:35.805Z","comments":true,"path":"about/index.html","permalink":"https://jiaan001.github.io/about/index.html","excerpt":"","text":"往者不可谏，来者犹可追。这是我在提升技术的路上，给自己的座右铭。 生活中，喜欢做一些有趣的事情，喜欢”整理好一切，继续出发的感觉“，每天都是充满希望的一天。 喜欢运动，比如跑步，打球，或者日常拉伸。 喜欢阅读，每个月读完一本书。 喜欢和让我能静下心的人交朋友。 想和我联系的朋友，可以发邮件给我。 我的邮箱：&#106;&#105;&#x61;&#x61;&#110;&#50;&#x30;&#50;&#x31;&#x40;&#x31;&#54;&#51;&#46;&#99;&#111;&#109;"},{"title":"分类","date":"2021-03-13T03:34:12.000Z","updated":"2021-03-13T05:55:11.283Z","comments":true,"path":"categories/index.html","permalink":"https://jiaan001.github.io/categories/index.html","excerpt":"","text":""},{"title":"链接","date":"2021-03-13T05:53:13.000Z","updated":"2021-03-13T10:43:59.873Z","comments":true,"path":"link/index.html","permalink":"https://jiaan001.github.io/link/index.html","excerpt":"","text":"1. 关注的博客：阮一峰的个人网站 程序羊 王垠 2. 编程LeetCode beginnersbook C++手册 acwing 牛客网"},{"title":"标签","date":"2021-03-13T03:31:43.000Z","updated":"2021-03-13T03:38:13.951Z","comments":true,"path":"tags/index.html","permalink":"https://jiaan001.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"705. 设计哈希集合","slug":"705-设计哈希集合","date":"2021-03-13T13:12:37.000Z","updated":"2021-03-14T01:53:16.587Z","comments":true,"path":"2021/03/13/705-设计哈希集合/","link":"","permalink":"https://jiaan001.github.io/2021/03/13/705-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/","excerpt":"","text":"1. 题目不使用任何内建的哈希表库设计一个哈希集合（HashSet）。 实现 MyHashSet 类： void add(key) 向哈希集合中插入值 key 。 bool contains(key) 返回哈希集合中是否存在这个值 key 。 void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 2. 思路分析注意，这道题不能使用内建的哈希表库来解。 回忆起当初学习哈希表数据结构，依稀记得，在实现的过程中一定要处理好两个关键点，分别是哈希函数和冲突。这道题需要实现的是给定的MyHashSet类，类里有三个方法。如果使用设计哈希函数和解决冲突的方法解这道题，则这三个函数都需要基于哈希函数来实现。其中的关键点我在代码实现中，用注释说明了。 哈希函数设计为：int index = key % n;解决冲突：不断的试探下一个位置是否有效。 最后分析一下输入输出（对着解释看）。 输入： 12[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;][[], [1], [2], [1], [3], [2], [2], [2], [2]] 输出： 1[null, null, null, true, false, null, true, null, false] 解释： 123456789MyHashSet myHashSet &#x3D; new MyHashSet();myHashSet.add(1); &#x2F;&#x2F; set &#x3D; [1]myHashSet.add(2); &#x2F;&#x2F; set &#x3D; [1, 2]myHashSet.contains(1); &#x2F;&#x2F; 返回 TruemyHashSet.contains(3); &#x2F;&#x2F; 返回 False ，（未找到）myHashSet.add(2); &#x2F;&#x2F; set &#x3D; [1, 2]myHashSet.contains(2); &#x2F;&#x2F; 返回 TruemyHashSet.remove(2); &#x2F;&#x2F; set &#x3D; [1]myHashSet.contains(2); &#x2F;&#x2F; 返回 False ，（已移除） 3. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940class MyHashSet &#123; &#x2F;** Initialize your data structure here. *&#x2F; int[] data; int n &#x3D; 10000; &#x2F;&#x2F; 题目中提示最多调用 104 次 add、remove 和 contains public MyHashSet() &#123; data &#x3D; new int[n]; Arrays.fill(data,-1); &#x2F;&#x2F;题目提示，数据取值范围是：0 &lt;&#x3D; key &lt;&#x3D; 106。所以，先用-1代表未赋值 &#125; &#x2F;&#x2F; 哈希函数的设计 public int check(int key)&#123; int index &#x3D; key % n; &#x2F;&#x2F; 解决冲突 while(data[index] !&#x3D; key &amp;&amp; data[index] !&#x3D; -1)&#123; index++; &#x2F;&#x2F; 有冲突时，不断的试探下一个位置是否可以 &#x2F;* 注意，必须进行下面条件的判断，否则将出现该错误： java.lang.ArrayIndexOutOfBoundsException: Index 10000 out of bounds for length 10000 *&#x2F; if(index &#x3D;&#x3D; n)&#123; index &#x3D; 0; &#125; &#125; return index; &#125; &#x2F;&#x2F; 经过哈希函数，进行add public void add(int key)&#123; data[check(key)] &#x3D; key; &#125; &#x2F;&#x2F; 删除数据后，用-2表示。有两个目的，首先表示已删除，其次通过这个位置，访问其他位置的数据依然有效。 public void remove(int key)&#123; if(data[check(key)] !&#x3D; -1)&#123; data[check(key)] &#x3D; -2; &#125; &#125; &#x2F;&#x2F; 如果当前位置数据大于等于零，则表示存在。 public boolean contains(int key)&#123; return data[check(key)] &gt;&#x3D; 0; &#125;&#125; 4. 总结这道题我用的是线性试探法来解的，简单来说，就是通过简单的哈希函数和不断试探解决冲突，然后实现了给定类的三个方法。题解中还有使用数组、链表、位运算的相关方法。比如，这位大佬的一题三解，值得学习。","categories":[{"name":"基础训练","slug":"基础训练","permalink":"https://jiaan001.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://jiaan001.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"}]},{"title":"331. 验证二叉树的前序序列化","slug":"331-验证二叉树的前序序列化","date":"2021-03-12T12:21:22.000Z","updated":"2021-03-14T01:51:41.547Z","comments":true,"path":"2021/03/12/331-验证二叉树的前序序列化/","link":"","permalink":"https://jiaan001.github.io/2021/03/12/331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"1. 题目序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。 例如，上面的二叉树可以被序列化为字符串 “9,3,4,#,#,1,#,#,2,#,6,#,#”，其中 # 代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 ‘#’ 。 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 “1,,3” 。 2. 思路分析目标：验证二叉树的前序序列号，并且在不重构树的条件下完成。输入：字符串，#表示空节点，如： 19,3,4,#,#,1,#,#,2,#,6,#,#&quot; 输出：true 或者 false解题方法：使用二叉树这个性质：若在任意一棵二叉树中，有n0个叶子节点，有n2个度为2的节点，则必有n0=n2+1。所以，可以将给定的序列号看成一棵完整的二叉树，验证是否满足这个性质，如果不满足，一定不是二叉树。 所以代码实现的限制条件是：条件1：叶子节点+1=非叶子节点个数。条件2：如果计数器标志在某时刻为负，则说明不是二叉树结构。 3. 代码实现12345678910111213141516class Solution &#123; public boolean isValidSerialization(String preorder) &#123; String[] str &#x3D; preorder.split(&quot;,&quot;); int flag &#x3D; 1; for (int i &#x3D; 0; i &lt; str.length; i++) &#123; flag--; if(flag &lt; 0)&#123; return false; &#125; if(!str[i].equals(&quot;#&quot;))&#123; flag +&#x3D; 2; &#125; &#125; return flag &#x3D;&#x3D; 0; &#125;&#125; 4. 总结题解中，还有用辅助栈并结合本题“前序遍历”的条件来解这道题，方法也很好。栈的思路就是自底向上，一步步判断，先判断左子树是否有效，再判断右子树，最后判断出整棵树是否有效。相比之下，利用二叉树的特性求解这道题，更加简洁。","categories":[{"name":"基础训练","slug":"基础训练","permalink":"https://jiaan001.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://jiaan001.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"}]},{"title":"Character类相关操作的简单练习","slug":"Character类相关操作的简单练习","date":"2021-03-09T06:20:52.000Z","updated":"2021-03-14T01:52:58.402Z","comments":true,"path":"2021/03/09/Character类相关操作的简单练习/","link":"","permalink":"https://jiaan001.github.io/2021/03/09/Character%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E7%9A%84%E7%AE%80%E5%8D%95%E7%BB%83%E4%B9%A0/","excerpt":"","text":"1. 题目首先编写从键盘读取字符串的程序。 其次该程序应将每个单词的首字母更改为大写。 最后在屏幕上显示结果。 1.1 示例输入：1hello world. 1.2 示例输出：1Hello World. 2. 程序实现123456789101112131415public class Solution &#123; public static void main(String[] args) throws IOException &#123; BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(System.in)); String s &#x3D; reader.readLine(); char[] ch &#x3D; s.toCharArray(); ch[0] &#x3D; Character.toUpperCase(ch[0]); for (int i &#x3D; 0; i &lt; ch.length-1; i++) &#123; if(Character.isLetter(ch[i+1])&amp;&amp;ch[i]&#x3D;&#x3D;&#39; &#39;)&#123; ch[i+1] &#x3D; Character.toUpperCase(ch[i+1]); &#125; &#125; String result &#x3D; new String(ch); System.out.println(result); &#125;&#125; 3. 总结首先需要知道的是Character类提供了一系列方法来操作字符，并且操作对象是单个字符。而与之相对应的，String是对一个字符序列的操作，StringBuffer是对一串字符进行操作。 这个题目中，用到了Character类中的方法是： 方法名称 功能 toUpperCase() 指定字母的大写形式 isLetter() 是否是一个字母 其他常用方法： 方法名称 功能 isDigit() 是否是一个数字字符 isWhitespace() 是否是一个空白字符 isLowerCase() 是否是小写字母 isUpperCase() 是否是大写字母 toLowerCase() 指定字母的小写形式 toString() 返回字符的字符串形式，字符串的长度仅为1","categories":[{"name":"基础训练","slug":"基础训练","permalink":"https://jiaan001.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83/"}],"tags":[{"name":"java基础反复练习","slug":"java基础反复练习","permalink":"https://jiaan001.github.io/tags/java%E5%9F%BA%E7%A1%80%E5%8F%8D%E5%A4%8D%E7%BB%83%E4%B9%A0/"}]}],"categories":[{"name":"基础训练","slug":"基础训练","permalink":"https://jiaan001.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://jiaan001.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"java基础反复练习","slug":"java基础反复练习","permalink":"https://jiaan001.github.io/tags/java%E5%9F%BA%E7%A1%80%E5%8F%8D%E5%A4%8D%E7%BB%83%E4%B9%A0/"}]}