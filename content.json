{"meta":{"title":"An的博客","subtitle":"山中何事","description":"个人技术博客","author":"An","url":"https://jiaan001.github.io","root":"/"},"pages":[{"title":"关于An","date":"2021-03-13T10:51:02.000Z","updated":"2021-06-28T03:37:30.699Z","comments":true,"path":"about/index.html","permalink":"https://jiaan001.github.io/about/index.html","excerpt":"","text":"往者不可谏，来者犹可追。这是我在提升技术的路上，给自己的座右铭。 生活中，喜欢做一些有趣的事情，喜欢”整理好一切，继续出发的感觉“，每天都是充满希望的一天。 喜欢运动，比如跑步，打球，跳绳。 喜欢阅读，每个月读完一本书。 喜欢和让我能静下心的人交朋友。 想和我联系的朋友，可以发邮件给我。 我的邮箱：&#x6a;&#105;&#97;&#97;&#110;&#x32;&#48;&#50;&#x31;&#x40;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;"},{"title":"分类","date":"2021-03-13T03:34:12.000Z","updated":"2021-03-13T05:55:11.283Z","comments":true,"path":"categories/index.html","permalink":"https://jiaan001.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-03-13T03:31:43.000Z","updated":"2021-03-13T03:38:13.951Z","comments":true,"path":"tags/index.html","permalink":"https://jiaan001.github.io/tags/index.html","excerpt":"","text":""},{"title":"链接","date":"2021-03-13T05:53:13.000Z","updated":"2021-06-28T13:56:25.737Z","comments":true,"path":"link/index.html","permalink":"https://jiaan001.github.io/link/index.html","excerpt":"","text":"1. 关注的博客：阮一峰的个人网站 程序羊 王垠 2. 编程LeetCode beginnersbook C++手册 acwing 牛客网 3. 测试开发TesterHome 软件测试论坛"}],"posts":[{"title":"什么是高可用","slug":"什么是高可用","date":"2021-06-30T04:53:28.000Z","updated":"2021-06-30T05:31:59.096Z","comments":true,"path":"2021/06/30/什么是高可用/","link":"","permalink":"https://jiaan001.github.io/2021/06/30/%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%8F%AF%E7%94%A8/","excerpt":"","text":"高可用通常是指系统所能提供无故障服务的一种能力。一种相对严谨的定义如下： 可用性是衡量系统在一段时间内提供可用资源状况的一个指标。 计算公式：A = 100 - （ 100 * D / U ）D表示计划外停机时间，U表示正常运行时间。 业界中，通常用“几个九”来描述系统的可用性，如下所示： 可用性% 停机分钟数 一年内停机时间 业界术语 90 52560.00 36.5 天 1 个 9 99 5256.00 4 天 2 个 9 99.9 525.60 8.8 小时 3 个 9 99.99 52.56 53 分钟 4 个 9 99.999 5.26 5.3 分钟 5 个 9 99.9999 0.53 32 秒 6 个 9 一个高可用的系统，通常需满足：可用性达到4个9以上。并且出现故障后，可以快速发现故障，然后通过冗余、故障转移等方式及时止损。其中，冗余指建一个备份集群，然后将故障流量切到备份集群；故障转移指将故障的集群流量切掉。","categories":[{"name":"测试开发","slug":"测试开发","permalink":"https://jiaan001.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"https://jiaan001.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"性能测试指标的理解","slug":"性能测试指标的理解","date":"2021-06-29T04:51:46.000Z","updated":"2021-06-29T05:34:22.897Z","comments":true,"path":"2021/06/29/性能测试指标的理解/","link":"","permalink":"https://jiaan001.github.io/2021/06/29/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8C%87%E6%A0%87%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"1. 主要指标性能测试的指标很多，业务不同，关注的指标也可能不同。我主要是基于我司大促压测，分享几个主要指标的个人理解。 1.1 QPSQPS（Queries Per Second）是每秒查询率。是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，即每秒的响应请求数，也是最大吞吐能力。通常希望越大越好。 1.2 TPS（最大/平均）TPS（Transactions Per Second）是每秒事务数。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。所以，一个TPS它应该包括三个过程： 用户请求服务器； 服务器的内部处理； 服务器返回给用户。 每秒完成多少个TPS，它的TPS就是多少。通常希望越大越好。比如：查询jimdb缓存，预期每分钟调用量为10万，则TPS平均 = 100000/60 ≈ 1667（事务数/秒） TPS峰值：符合帕累托法则，即80%的调用量发生在20%的时间内。比如：查询jimdb缓存，预期每分钟调用量为10万，则TPS峰值 = 100000 * 80%/(60 * 20%) ≈ 6667（事务数/秒）= 4TPS（平均） QPS和TPS的关联：两者都是衡量系统处理能力的重要指标。QPS是查询，TPS是事务。事务是查询的入口，也可能包含其他类型的业务场景，所以，QPS应该是TPS的子集。 1.3 响应时间系统对请求做出响应的时间。指执行一个请求从开始到最后收到响应数据所用的总时间。比如：向服务器A发送请求时间为T1，服务器A处理请求时间（思考时间）为T2，服务器A返回信息的时间为T3，则响应时间T=T1+T2+T3。通常希望响应时间越小越好。 1.4 TP值（50/99/999）TP=TP Percentile，Top百分位数，是一个统计学里的术语，与平均数、中位数都是一类。TP指标指在一个时间段内，统计该方法每次调用所消耗的时间，并将这些时间按照从小到大的顺序进行排序，并取出结果：对应TP指标的序号=总次数 * 指标数，然后再根据序号取出排序好的时间，即为TP指标。TP50、TP99、TP999等指标常用于系统性能监控场景，指高于50%、99%、99.9%百分线的情况。 TP50：指在一个时间段内（如5分钟），统计该方法每次调用所消耗的时间，并将这些时间按照从小到大的顺序进行排序，取第50%的那个值作为TP50的值。配置此监控指标对应的报警阈值后，需要保证在这个时间段内该方法所有调用的消耗时间至少有50%的值要小于此阈值，否则系统将会报警。 TP99和TP999与TP50值计算方法相同，它们分别代表着对方法的不同性能要求，TP50相对较低，TP99，TP999则对方法性能要求很高。 比如：假设有一个方法testTP()，6次请求响应时间为：13ms，38ms，23ms，45ms，17ms，56ms，升序排序后为[13ms,17ms,23ms,38ms,45ms,56ms]，则：TP50：6 * 50% = 3TP99：6 * 99% = 5.4 ~ 6TP999：6 * 99.9% = 5.994 ~ 6然后，根据百分数的定义可得：TP50=23ms（取排序为3的值）TP99=56ms（取排序为6的值）TP999=56ms（取排序为6的值） 最后再具体应用具体分析。在接口被调用的情况下，相同时间内，TP99、TP999越低越好。 1.5 并发数指系统可以同时承载的正常使用系统功能的用户的数量。比如：某个地铁站进站有10个闸机，可以允许10个人同时进站，则并发数为10。 1.6 CPU、内存使用率CPU使用率：CPU功能是处理计算机指令及计算机软件中的数据。其使用率分为用户态，系统态和空闲态，分别表示CPU处于用户态执行的时间，系统内核执行的时间和空闲系统进程执行的时间。通常CPU使用率指：CPU执行非系统空闲进程的时间/CPU总的执行时间。标准可以定义为： CPU使用率&lt;=70%，好 CPU使用率&gt;70%且&lt;=90%，坏 CPU使用率&gt;90%，很差 内存使用率：内存作用是用于暂时存放CPU中的运算数据，及与硬盘等外部存储器交换的数据。其使用率是指此进程所开销的内存。标准可以定义为： 没有页面交换，好 每个CPU每秒10个页面交换，坏 每个CPU每秒超过10个页面交换，很差 交换指当系统中实际的内存已不够满足新的分配需求组时，把整个进程传输到磁盘上。交换活动通常意味着内存不足。 另外，类似的，也可以查看磁盘指标和网卡负载情况。此次压测中并未重点关注这两个指标。 2. 分析指标压测前： 记录CPU、内存使用率。压测前，压力机的CPU、内存使用率应该都是很低的。比如我司压力机CPU使用率大概保持在3%到5%之间。压测进行中： 此次压测中，加压前后主要关注两个指标：其一是调用量，观察是否达到预期目标；其二是CPU、内存使用率，查看当前状态是否在合理范围内，是否突然负载过大。当两个指标都正常时，系统加压稳定后，如果还未到达预期目标，会继续加压，继续关注两个指标。当到达预期目标后，停止发压，记录所有性能指标，分析此次压测结果。如果未到达预期目标，则分析原因，进行系统优化，再重新压测。压测后： 查看其他指标是否正常。所有指标在正常范围之内，则表示此次压测达到预期目标，系统稳定性良好。如果有指标不正常，则应该进行相应的分析处理，进行扩容或者去掉老旧机器等，具体原因具体分析。 3. 总结压测不是目的，压测后分析压测结果才是目的。因此，做性能压测时，需要牢牢理解掌握这些性能指标。然后更好的分析问题、定位和调优。 以上内容皆基于调研和实践，若有不当之处，恳请指正，欢迎交流。 参考文章https://mp.weixin.qq.com/s/Fhe05FhbvGhBLCqJSK07kwhttps://testerhome.com/articles/20744https://testerhome.com/articles/21178https://zhuanlan.zhihu.com/p/76810090https://stackoverflow.com/questions/17435438/what-do-we-mean-by-top-percentile-or-tp-based-latency/17458579#17458579","categories":[{"name":"测试开发","slug":"测试开发","permalink":"https://jiaan001.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"https://jiaan001.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"第一次做性能测试的思考总结","slug":"第一次做性能测试的思考总结","date":"2021-06-28T03:10:50.000Z","updated":"2021-06-28T13:48:30.107Z","comments":true,"path":"2021/06/28/第一次做性能测试的思考总结/","link":"","permalink":"https://jiaan001.github.io/2021/06/28/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%81%9A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/","excerpt":"","text":"实习期间很幸运有机会参与到我司的性能压测，并独立负责完成了两个应用的性能压测。大促见证了压测的必要性和重要性，因此，我想分享一下我第一次做压测的思考总结，欢迎感兴趣的朋友和我交流。 1. 背景大促间的流量，尤其是瞬时流量峰值是惊人的。在瞬时惊人的大流量面前，所有的问题都会被重新定义，任何简单的事情都会变得不简单。我司作为一个大电商公司，前端网站、搜索、下单、结算、配送、仓储、客服、售后等众多业务框架下，系统多，应用多，不管哪一个出问题，都会造成难以估计的损失。因此，大促前需要做很多备战工作，性能压测就是其中一环，确保系统高可用，给用户提供优质的体验。 2. 目的大促备战核心目的：在大促期间的超高流量下要保证整个系统的高可用。性能压测的目的：以应用级接口是否满足大促流量目标。 通过压测指标评估系统性能，指标包括并发数、QPS、TPS、响应时间、TP值、调用量、可用率、CPU使用率、内存使用率等； 发现系统短板进行系统调优，合理分配资源； 检测系统问题，验证系统的稳定性和可靠性。 3. 压测流程3.1 压测计划产品、研发、测试、运维、DBA多方沟通协调，确定压测计划。 3.2 压测策略 梳理业务接口及上下游依赖、中间件依赖； 制定压测策略，包括单接口压测、混合压测、压测范围、压测目标、压测工具、压测方式等； 压测方式为高保真压测时，需要确定压测工具、真实的压测数据量、真实的压测流量配比、真实的数据复杂度等。 3.3 压测准备 产品、研发、测试、运维、DBA多方沟通协调，完成压测报备； 准备压测数据； 编写压测脚本，并调试成功； 选择合适的时间段，进行小并发试压，检查链路配置是否正确，验证脚本和数据是否正确，观察压测流量是否命中目标服务器。 3.4 压测进行 根据业务需求或者压测目标判断是否需要调整压测策略； 压测进行中需要实时关注相关监控平台，及时处理异常情况； 详细记录业务系统压测过程中的各种异常场景。 3.5 压测结束 分析压测结果是否满足目标要求，分析系统瓶颈及优化策略； 压测完成后，确认压力机停止发压； 分析、总结并整理成压测报告； 跟踪并落实压测报告中所记录的问题。 4. 注意事项1）准备压测数据不宜过早，压测前两天开始准备较合适。压测数据格式需要和脚本读取入参格式一致，因此，先用一条压测数据调通脚本，再准备大量压测数据，较为合适，可以防止重复准备数据。2）为保证压测任务顺利进行，可以在脚本调通和数据准备好后，在晚上合适的时间以1并发提前试压，保证准备工作无误。3）压测脚本中按照配比执行对应事务，因此，为了快速定位error，可以在每个事务中进行标记打印，尤其是一个脚本中包含多个接口时，感觉非常有必要。4）http接口脚本中需要每天更新浏览器cookie值，一般是找到单点登录的那一项更新即可。如果分不清楚具体哪个或者哪几个时，可以将所有cookie值拿来用。5）压测前后及时记录CPU使用率、内存使用率，压测环境信息，写压测报告时需要。6）压测中，应及时频繁查看监控平台数据，每加压后，及时在监控平台中查看CPU使用率、内存使用率情况，确保加压安全性。另外，若发现性能指标异常，要及时记录和分析异常。7）压测后，应及时关掉压测任务。 5. 个人总结此次压测中，仅限于读接口的压测，未涉及写接口压测。我所在部门目前为止没有独立的测试环境进行写接口压测，用真实数据进行写接口压测会影响线上业务。压测的意义在于分析压测结果，根据压测结果，系统可以针对性的限流、降级、扩容等，完成系统性能调优，确保系统万无一失。","categories":[{"name":"测试开发","slug":"测试开发","permalink":"https://jiaan001.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"https://jiaan001.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"事务","slug":"事务","date":"2021-04-03T06:44:12.000Z","updated":"2021-04-03T06:46:32.660Z","comments":true,"path":"2021/04/03/事务/","link":"","permalink":"https://jiaan001.github.io/2021/04/03/%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://jiaan001.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://jiaan001.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"堆栈跟踪和异常捕获","slug":"堆栈跟踪和异常捕获","date":"2021-03-14T11:06:54.000Z","updated":"2021-03-14T11:20:14.176Z","comments":true,"path":"2021/03/14/堆栈跟踪和异常捕获/","link":"","permalink":"https://jiaan001.github.io/2021/03/14/%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/","excerpt":"","text":"1. 返回堆栈跟踪（1）直接获取当前线程的堆栈信息 1234public static StackTraceElement[] method1() &#123; method2(); return Thread.currentThread().getStackTrace();&#125; （2）返回调用它的方法的名称使用StackTraceElement 类的 getMethodName 方法 12345public static String method1() &#123; method2(); StackTraceElement[] stackTraceElements &#x3D; Thread.currentThread().getStackTrace(); return stackTraceElements[2].getMethodName();&#125; method1是main调用的，所以如果输出返回内容，则为main。 注意：stackTraceElement[0].getMethodName(); ——得到getStackTracestackTraceElement[1].getMethodName(); ——得到它自己的名称 （3）返回调用它的代码的行号使用StackTraceElement 类的 getLineNumber 方法。 12345public static int method1() &#123; method2(); StackTraceElement[] stackTraceElements &#x3D; Thread.currentThread().getStackTrace(); return stackTraceElements[2].getLineNumber();&#125; （4）返回堆栈跟踪深度堆栈跟踪的深度也就是求堆栈跟踪中的方法数量。使用 Thread.currentThread().getStackTrace()实现如下： 123456public static int getStackTraceDepth() &#123; StackTraceElement[] stackTraceElements &#x3D; Thread.currentThread().getStackTrace(); int stackTraceLength &#x3D; stackTraceElements.length; System.out.println(stackTraceLength); return stackTraceLength;&#125; 2. 对异常的总结首先异常是一种特殊的机制，可以让我们在程序中处理错误。比如程序中可能发生一些这样的错误：程序可能会在硬盘已满时尝试写入文件，程序中可能出现数字除以0的情况，等等。所有这些动作都会导致错误。通常，结果是程序立即终止，因为在这种情况下继续执行代码没有意义。 java中，异常分为必须捕获的异常和不必捕获的异常。默认情况下，必须捕获所有异常。异常的分类和继承关系如下。 其中，Java规定： 必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。 不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。 异常处理机制： 异常抛出：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。用throw语句抛出。 异常捕获：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。用try … catch捕获。把可能发生异常的语句放在try { … }中，然后使用catch捕获对应的Exception及其子类。 2.1 异常只捕获异常1234567891011121314151617public class Solution &#123; public static void main(String[] args) throws Exception &#123; method1(); &#125; public static void method1() throws NullPointerException, ArithmeticException, FileNotFoundException, URISyntaxException &#123; int i &#x3D; (int) (Math.random() * 4); if (i &#x3D;&#x3D; 0) throw new NullPointerException(); if (i &#x3D;&#x3D; 1) throw new ArithmeticException(); if (i &#x3D;&#x3D; 2) throw new FileNotFoundException(); if (i &#x3D;&#x3D; 3) throw new URISyntaxException(&quot;&quot;, &quot;&quot;); &#125;&#125; 上面代码中method1方法会抛出两个继承 Exception 的异常和两个继承 RuntimeException 的异常：NullPointerException, ArithmeticException, FileNotFoundException, URISyntaxException.此时你要捕获 NullPointerException 和 FileNotFoundException，而不捕获 ArithmeticException 或 URISyntaxException。 限制条件是： main 方法必须调用 method1。 不要更改 method1 方法。 main 方法必须捕获 NullPointerException 异常。 main 方法必须捕获 FileNotFoundException 异常。 main 方法不得捕获 ArithmeticException 异常。 main 方法不得捕获 URISyntaxException 异常。 如何做到这一点呢？ 具体实现中，我的实现方式是，在main方法中指定出需要捕获的具体异常即可，代码为： 1234567public static void main(String[] args) throws Exception &#123; try &#123; method1(); &#125; catch (NullPointerException | FileNotFoundException e) &#123; System.out.println(&quot;异常捕获：&quot; + e); &#125;&#125; 2.2 捕获一组异常此时由于会存在多个catch，导致catch的顺序将非常重要，实现时遵循一个原则：子类必须写在前面。 练习题目：1.有三个连续继承 Exception 的异常。2.Exception1 类 extends Exception3.Exception2 类 extends Exception14.Exception3 类 extends Exception25.有一种方法如下：public static void method1() throws Exception1, Exception2, Exception36.编写一个捕获所有如下三个异常的 catch 块：Exception1、Exception2 和 Exception3 Requirements:1. main 方法必须调用 method1。2. main 方法必须捕获 Exception1 异常。3. main 方法必须捕获 Exception2 异常。4. main 方法必须捕获 Exception3 异常。5. 不要更改 method1 方法。 1234567891011121314public class Solution &#123; public static void main(String[] args) throws Exception &#123; method1(); &#125; public static void method1() throws Exception1, Exception2, Exception3 &#123; int i &#x3D; (int) (Math.random() * 3); if (i &#x3D;&#x3D; 0) throw new Exception1(); if (i &#x3D;&#x3D; 1) throw new Exception2(); if (i &#x3D;&#x3D; 2) throw new Exception3(); &#125;&#125; 遵循子类必须写在前面的原则后，我在main方法中实现如下： 12345678910111213public static void main(String[] args) throws Exception &#123; try &#123; method1(); &#125; catch (Exception3 e) &#123; &#125; catch (Exception2 e) &#123; &#125; catch (Exception1 e) &#123; &#125; catch (Exception e) &#123; &#125;&#125; 2.3 捕获自定义异常给定代码如下： 123456789101112131415161718192021222324252627public class Solution &#123; public static StatelessBean BEAN &#x3D; new StatelessBean(); public static void main(String[] args) &#123; handleExceptions(); &#125; public static void handleExceptions() &#123; BEAN.throwExceptions(); &#125; public static class StatelessBean &#123; public void log(Exception exception) &#123; System.out.println(exception.getMessage() + &quot;, &quot; + exception.getClass().getSimpleName()); &#125; public void throwExceptions() throws CharConversionException, FileSystemException, IOException &#123; int i &#x3D; (int) (Math.random() * 3); if (i &#x3D;&#x3D; 0) throw new CharConversionException(); if (i &#x3D;&#x3D; 1) throw new FileSystemException(&quot;&quot;); if (i &#x3D;&#x3D; 2) throw new IOException(); &#125; &#125;&#125; 题目如下： 1. 分析由 BEAN.throwExceptions 方法抛出的异常。 2. handleExceptions 方法必须调用 BEAN.throwExceptions 方法并处理异常： 2.1. 如果有一个 FileSystemException，则记录下来（调用 BEAN.log 方法）并重新抛出。 2.2. 如果有一个 CharConversionException 或任何其他 IOException，则只需记录下来（调用 BEAN.log 方法)）。 3. 在 handleExceptions 方法中添加项目 2.1 中抛出的异常类。 4. 在 main 方法中，记录异常以处理剩余异常。使用 try-catch。 Requirements: 1. handleExceptions 方法应记录 FileSystemException（调用 BEAN.log 方法），然后将其重新抛出。 1. handleExceptions 方法应只记录 CharConversionException（调用 BEAN.log 方法）。 3. handleExceptions 方法应只记录 IOException。 4. 在 handleExceptions 方法中添加 FileSystemException 类。 5. main 方法应使用 try-catch。 6. main 方法应记录 handleExceptions 方法抛出的异常。 这道简单的题目在捕获自定义的基础上，考察了异常捕获和抛出的结合的基本操作。比如限制条件1考察的是捕获到异常，然后将该异常再重新抛出。我的实现方式是： 123456789101112131415161718public static void main(String[] args) &#123; try &#123; handleExceptions(); &#125;catch (Exception e)&#123; BEAN.log(e); &#125; &#125;public static void handleExceptions() throws FileSystemException&#123; try &#123; BEAN.throwExceptions(); &#125; catch (FileSystemException e)&#123; BEAN.log(e); throw e; &#125; catch (IOException e) &#123; BEAN.log(e); &#125;&#125; 2.4 显示所发生的异常的堆栈跟踪实现如下。在 handleExceptions 方法中，处理所有未检查异常。然后使用 printStack 方法来显示所发生的异常的堆栈跟踪。 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public static void main(String[] args) &#123; handleExceptions(new Solution()); &#125; public static void handleExceptions(Solution obj) &#123; try &#123; obj.method1(); obj.method2(); obj.method3(); &#125; catch (Exception e)&#123; printStack(e); &#125; &#125; public static void printStack(Throwable throwable) &#123; System.out.println(throwable); for (StackTraceElement element : throwable.getStackTrace()) &#123; System.out.println(element); &#125; &#125; public void method1() &#123; throw new NullPointerException(); &#125; public void method2() &#123; throw new IndexOutOfBoundsException(); &#125; public void method3() &#123; throw new NumberFormatException(); &#125;&#125; 3. 一个小练习要求：编写一个程序，该程序将从键盘读取数字 。从键盘读取数字的代码必须在 readData 方法中。将 readData 中的代码封装在 try-catch 块中。如果用户输入文本而不是数字，则该方法应捕获异常 ，然后显示所有先前输入的数字。在新行中按之前输入的顺序显示每个数字。 我的实现代码： 123456789101112131415161718192021public class Solution &#123; public static void main(String[] args) &#123; readData(); &#125; public static void readData() &#123; ArrayList&lt;Integer&gt; arrayList &#x3D; new ArrayList&lt;&gt;(); try &#123; BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(System.in)); while (true)&#123; int num &#x3D; Integer.parseInt(reader.readLine()); arrayList.add(num); &#125; &#125; catch (Exception e) &#123; for (Integer i: arrayList) &#123; System.out.println(i); &#125; &#125; &#125;&#125; 4. 总结通过几个小题目，不仅练习了异常的捕获和抛出，而且进一步的研究了堆栈跟踪。在实现中，当有继承关系时，需要注意catch的匹配顺序。另外，打印异常的传播线，可以帮助代码的调试。","categories":[{"name":"基础训练","slug":"基础训练","permalink":"https://jiaan001.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83/"}],"tags":[{"name":"java基础反复练习","slug":"java基础反复练习","permalink":"https://jiaan001.github.io/tags/java%E5%9F%BA%E7%A1%80%E5%8F%8D%E5%A4%8D%E7%BB%83%E4%B9%A0/"}]},{"title":"时间格式的转换","slug":"时间格式的转换","date":"2021-03-14T07:16:22.000Z","updated":"2021-06-28T02:41:46.711Z","comments":true,"path":"2021/03/14/时间格式的转换/","link":"","permalink":"https://jiaan001.github.io/2021/03/14/%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"1. 题目按格式“2021-03-14”输入日期，以“MAR 14, 2021”格式显示日期。使用 Date 对象和 SimpleDateFormat。 2. 程序实现我的思路是：首先确定输入时间的格式，这个输入的是String类型。然后将这个String类型的时间转化成Date类型，这个转化中会用到SimpleDateFormat类来格式化时间，确定要输出的时间格式，将Date的时间类型转化成要输出的格式。最后使用toUpperCase()将月份字母全变成大写。 123456789101112public class Solution &#123; public static void main(String[] args) throws Exception &#123; BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(System.in)); String str &#x3D; reader.readLine(); SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date &#x3D; sdf.parse(str); String sdfDateFormat &#x3D; &quot;MMM dd, yyy&quot;; SimpleDateFormat sdfDate &#x3D; new SimpleDateFormat(sdfDateFormat); String output &#x3D; sdfDate.format(date.getTime()); System.out.println(output.toUpperCase()); &#125;&#125; 3. 总结经常使用的日期和时间的格式化编码：| 年 | 月 | 日 | 时 | 分 | 秒 || — | — | — | — | — | — || yyyy | MM | dd | HH | mm | ss | 需要注意：有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。 此外，如果使用LocalDateTime或ZonedLocalDateTime，进行格式化显示时，应该使用DateTimeFormatter。和SimpleDateFormat不同的是，DateTimeFormatter是不变对象，并且是线程安全的。相比之下，因为SimpleDateFormat不是线程安全的，所以使用时，只能在方法内部创建新的局部变量。而DateTimeFormatter可以只创建一个实例，到处引用。 LocalDateTime表示本地日期和时间，ZonedDateTime表示一个带时区的日期和时间。可以通过now()方法返回当前时间： 12LocalDateTime ldt &#x3D; LocalDateTime.now();ZonedDateTime zdt &#x3D; ZonedDateTime.now(); “不变对象”指对象一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何变化。","categories":[{"name":"基础训练","slug":"基础训练","permalink":"https://jiaan001.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83/"}],"tags":[{"name":"java基础反复练习","slug":"java基础反复练习","permalink":"https://jiaan001.github.io/tags/java%E5%9F%BA%E7%A1%80%E5%8F%8D%E5%A4%8D%E7%BB%83%E4%B9%A0/"}]},{"title":"705. 设计哈希集合","slug":"705-设计哈希集合","date":"2021-03-13T13:12:37.000Z","updated":"2021-03-14T11:27:49.454Z","comments":true,"path":"2021/03/13/705-设计哈希集合/","link":"","permalink":"https://jiaan001.github.io/2021/03/13/705-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/","excerpt":"","text":"1. 题目不使用任何内建的哈希表库设计一个哈希集合（HashSet）。 实现 MyHashSet 类： void add(key) 向哈希集合中插入值 key 。 bool contains(key) 返回哈希集合中是否存在这个值 key 。 void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 2. 思路分析注意，这道题不能使用内建的哈希表库来解。 回忆起当初学习哈希表数据结构，依稀记得，在实现的过程中一定要处理好两个关键点，分别是哈希函数和冲突。这道题需要实现的是给定的MyHashSet类，类里有三个方法。如果使用设计哈希函数和解决冲突的方法解这道题，则这三个函数都需要基于哈希函数来实现。其中的关键点我在代码实现中，用注释说明了。 哈希函数设计为：int index = key % n;解决冲突：不断的试探下一个位置是否有效。 最后分析一下输入输出（对着解释看）。 输入： 12[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;][[], [1], [2], [1], [3], [2], [2], [2], [2]] 输出： 1[null, null, null, true, false, null, true, null, false] 解释： 123456789MyHashSet myHashSet &#x3D; new MyHashSet();myHashSet.add(1); &#x2F;&#x2F; set &#x3D; [1]myHashSet.add(2); &#x2F;&#x2F; set &#x3D; [1, 2]myHashSet.contains(1); &#x2F;&#x2F; 返回 TruemyHashSet.contains(3); &#x2F;&#x2F; 返回 False ，（未找到）myHashSet.add(2); &#x2F;&#x2F; set &#x3D; [1, 2]myHashSet.contains(2); &#x2F;&#x2F; 返回 TruemyHashSet.remove(2); &#x2F;&#x2F; set &#x3D; [1]myHashSet.contains(2); &#x2F;&#x2F; 返回 False ，（已移除） 3. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940class MyHashSet &#123; &#x2F;** Initialize your data structure here. *&#x2F; int[] data; int n &#x3D; 10000; &#x2F;&#x2F; 题目中提示最多调用 10000 次 add、remove 和 contains public MyHashSet() &#123; data &#x3D; new int[n]; Arrays.fill(data,-1); &#x2F;&#x2F;题目提示，数据取值范围是：0 &lt;&#x3D; key &lt;&#x3D; 1000000。所以，先用-1代表未赋值 &#125; &#x2F;&#x2F; 哈希函数的设计 public int check(int key)&#123; int index &#x3D; key % n; &#x2F;&#x2F; 解决冲突 while(data[index] !&#x3D; key &amp;&amp; data[index] !&#x3D; -1)&#123; index++; &#x2F;&#x2F; 有冲突时，不断的试探下一个位置是否可以 &#x2F;* 注意，必须进行下面条件的判断，否则将出现该错误： java.lang.ArrayIndexOutOfBoundsException: Index 10000 out of bounds for length 10000 *&#x2F; if(index &#x3D;&#x3D; n)&#123; index &#x3D; 0; &#125; &#125; return index; &#125; &#x2F;&#x2F; 经过哈希函数，进行add public void add(int key)&#123; data[check(key)] &#x3D; key; &#125; &#x2F;&#x2F; 删除数据后，用-2表示。有两个目的，首先表示已删除，其次通过这个位置，访问其他位置的数据依然有效。 public void remove(int key)&#123; if(data[check(key)] !&#x3D; -1)&#123; data[check(key)] &#x3D; -2; &#125; &#125; &#x2F;&#x2F; 如果当前位置数据大于等于零，则表示存在。 public boolean contains(int key)&#123; return data[check(key)] &gt;&#x3D; 0; &#125;&#125; 4. 总结这道题我用的是线性试探法来解的，简单来说，就是通过简单的哈希函数和不断试探解决冲突，然后实现了给定类的三个方法。题解中还有使用数组、链表、位运算的相关方法。比如，这位大佬的一题三解，值得学习。","categories":[{"name":"基础训练","slug":"基础训练","permalink":"https://jiaan001.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://jiaan001.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"}]},{"title":"331. 验证二叉树的前序序列化","slug":"331-验证二叉树的前序序列化","date":"2021-03-12T12:21:22.000Z","updated":"2021-03-14T01:51:41.547Z","comments":true,"path":"2021/03/12/331-验证二叉树的前序序列化/","link":"","permalink":"https://jiaan001.github.io/2021/03/12/331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"1. 题目序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。 例如，上面的二叉树可以被序列化为字符串 “9,3,4,#,#,1,#,#,2,#,6,#,#”，其中 # 代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 ‘#’ 。 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 “1,,3” 。 2. 思路分析目标：验证二叉树的前序序列号，并且在不重构树的条件下完成。输入：字符串，#表示空节点，如： 19,3,4,#,#,1,#,#,2,#,6,#,#&quot; 输出：true 或者 false解题方法：使用二叉树这个性质：若在任意一棵二叉树中，有n0个叶子节点，有n2个度为2的节点，则必有n0=n2+1。所以，可以将给定的序列号看成一棵完整的二叉树，验证是否满足这个性质，如果不满足，一定不是二叉树。 所以代码实现的限制条件是：条件1：叶子节点+1=非叶子节点个数。条件2：如果计数器标志在某时刻为负，则说明不是二叉树结构。 3. 代码实现12345678910111213141516class Solution &#123; public boolean isValidSerialization(String preorder) &#123; String[] str &#x3D; preorder.split(&quot;,&quot;); int flag &#x3D; 1; for (int i &#x3D; 0; i &lt; str.length; i++) &#123; flag--; if(flag &lt; 0)&#123; return false; &#125; if(!str[i].equals(&quot;#&quot;))&#123; flag +&#x3D; 2; &#125; &#125; return flag &#x3D;&#x3D; 0; &#125;&#125; 4. 总结题解中，还有用辅助栈并结合本题“前序遍历”的条件来解这道题，方法也很好。栈的思路就是自底向上，一步步判断，先判断左子树是否有效，再判断右子树，最后判断出整棵树是否有效。相比之下，利用二叉树的特性求解这道题，更加简洁。","categories":[{"name":"基础训练","slug":"基础训练","permalink":"https://jiaan001.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://jiaan001.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"}]},{"title":"Character类相关操作的简单练习","slug":"Character类相关操作的简单练习","date":"2021-03-09T06:20:52.000Z","updated":"2021-03-14T01:52:58.402Z","comments":true,"path":"2021/03/09/Character类相关操作的简单练习/","link":"","permalink":"https://jiaan001.github.io/2021/03/09/Character%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E7%9A%84%E7%AE%80%E5%8D%95%E7%BB%83%E4%B9%A0/","excerpt":"","text":"1. 题目首先编写从键盘读取字符串的程序。 其次该程序应将每个单词的首字母更改为大写。 最后在屏幕上显示结果。 1.1 示例输入：1hello world. 1.2 示例输出：1Hello World. 2. 程序实现123456789101112131415public class Solution &#123; public static void main(String[] args) throws IOException &#123; BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(System.in)); String s &#x3D; reader.readLine(); char[] ch &#x3D; s.toCharArray(); ch[0] &#x3D; Character.toUpperCase(ch[0]); for (int i &#x3D; 0; i &lt; ch.length-1; i++) &#123; if(Character.isLetter(ch[i+1])&amp;&amp;ch[i]&#x3D;&#x3D;&#39; &#39;)&#123; ch[i+1] &#x3D; Character.toUpperCase(ch[i+1]); &#125; &#125; String result &#x3D; new String(ch); System.out.println(result); &#125;&#125; 3. 总结首先需要知道的是Character类提供了一系列方法来操作字符，并且操作对象是单个字符。而与之相对应的，String是对一个字符序列的操作，StringBuffer是对一串字符进行操作。 这个题目中，用到了Character类中的方法是： 方法名称 功能 toUpperCase() 指定字母的大写形式 isLetter() 是否是一个字母 其他常用方法： 方法名称 功能 isDigit() 是否是一个数字字符 isWhitespace() 是否是一个空白字符 isLowerCase() 是否是小写字母 isUpperCase() 是否是大写字母 toLowerCase() 指定字母的小写形式 toString() 返回字符的字符串形式，字符串的长度仅为1","categories":[{"name":"基础训练","slug":"基础训练","permalink":"https://jiaan001.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83/"}],"tags":[{"name":"java基础反复练习","slug":"java基础反复练习","permalink":"https://jiaan001.github.io/tags/java%E5%9F%BA%E7%A1%80%E5%8F%8D%E5%A4%8D%E7%BB%83%E4%B9%A0/"}]}],"categories":[{"name":"测试开发","slug":"测试开发","permalink":"https://jiaan001.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://jiaan001.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"基础训练","slug":"基础训练","permalink":"https://jiaan001.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"https://jiaan001.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"数据库","slug":"数据库","permalink":"https://jiaan001.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"java基础反复练习","slug":"java基础反复练习","permalink":"https://jiaan001.github.io/tags/java%E5%9F%BA%E7%A1%80%E5%8F%8D%E5%A4%8D%E7%BB%83%E4%B9%A0/"},{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://jiaan001.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"}]}